<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR Scanner — fallback frame-scan (iPhone friendly)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;display:flex;flex-direction:column;align-items:center;gap:12px;padding:18px;background:#f6f7fb;color:#111}
    .card{max-width:900px;width:100%;background:white;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,60,0.08)}
    video{width:100%;height:auto;border-radius:8px;background:#000}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
    button.primary{background:#0b69ff;color:white;border-color:transparent}
    #resultDisplay{word-break:break-all;padding:8px;background:#f3f6ff;border-radius:6px}
    input#resultInput{width:100%;padding:8px;border-radius:6px;border:1px solid #ccc}
    .hidden{display:none}
    .actions{display:flex;gap:8px;margin-top:8px}
    small.note{color:#666}
    .log{font-size:12px;color:#666;margin-top:8px;max-height:160px;overflow:auto;background:#fff;padding:8px;border-radius:6px;border:1px solid #eee}
  </style>
</head>
<body>
  <div class="card">
    <h2>QR Scanner — versione con fallback</h2>
    <p>Se Safari/iPhone non decodifica con il worker normale, questo fallback cattura fotogrammi dal video e prova a decodificarli con <code>QrScanner.scanImage()</code>. Provalo su HTTPS in Safari.</p>

    <div>
      <video id="video" muted playsinline></video>
    </div>

    <div class="controls">
      <button id="startBtn" class="primary">Avvia camera</button>
      <button id="stopBtn">Ferma</button>
      <select id="cameraSelect" aria-label="Seleziona fotocamera"></select>
      <button id="flipBtn">Cambia fotocamera</button>
      <label style="display:flex;gap:6px;align-items:center"><input id="torch" type="checkbox"> Torcia (se supportata)</label>
      <input id="fileInput" type="file" accept="image/*" />
    </div>

    <h4>Risultato</h4>
    <div id="resultDisplay">Nessun QR rilevato</div>
    <input id="resultInput" placeholder="Il contenuto del QR apparirà qui" readonly />
    <div class="actions hidden" id="actions">
      <button id="openBtn">Apri (se URL)</button>
      <button id="copyBtn">Copia</button>
      <button id="continueBtn">Continua scansione</button>
    </div>

    <p><small class="note">Consiglio: apri la pagina direttamente in Safari (no WebApp) e apri la console remota per leggere i log.</small></p>
    <div class="log" id="log"></div>
  </div>

  <script type="module">
    import QrScanner from 'https://unpkg.com/qr-scanner@1.4.2/qr-scanner.min.js';
    QrScanner.WORKER_PATH = 'https://unpkg.com/qr-scanner@1.4.2/qr-scanner-worker.min.js';

    const logEl = document.getElementById('log');
    function log(...args){ console.log(...args); logEl.innerText += args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resultDisplay = document.getElementById('resultDisplay');
    const resultInput = document.getElementById('resultInput');
    const cameraSelect = document.getElementById('cameraSelect');
    const flipBtn = document.getElementById('flipBtn');
    const torchCheckbox = document.getElementById('torch');
    const fileInput = document.getElementById('fileInput');
    const actions = document.getElementById('actions');
    const openBtn = document.getElementById('openBtn');
    const copyBtn = document.getElementById('copyBtn');
    const continueBtn = document.getElementById('continueBtn');

    let qrScanner = null;
    let devices = [];
    let currentDeviceId = null;
    let lastResult = null;
    let currentStream = null;
    let frameScanInterval = null;
    let frameCanvas = null;

    function pickRearCamera(cams){
      if(!cams || cams.length===0) return null;
      const re = /back|rear|environment|posteriore|posteri[oì]re|rear camera|back camera/i;
      for(const c of cams){ if(c.label && re.test(c.label)) return c; }
      if(cams.length>1) return cams[1];
      return cams[0];
    }

    function playVideoElement(){ return video.play ? video.play().catch(e => { log('video.play error', e); }) : Promise.resolve(); }

    async function ensurePermissions(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
        const devicesNow = await navigator.mediaDevices.enumerateDevices();
        const labelsPresent = devicesNow.some(d => d.kind === 'videoinput' && d.label);
        if(!labelsPresent){
          log('Labels vuote: richiedo permessi temporanei.');
          const tmpStream = await navigator.mediaDevices.getUserMedia({ video: true }).catch(e => { log('getUserMedia temporaneo fallito', e); return null; });
          if(tmpStream){ tmpStream.getTracks().forEach(t => t.stop()); log('Permesso concesso (stream temporaneo stoppato).'); } else { log('Permesso non concesso.'); }
        }
      }catch(e){ log('ensurePermissions error', e); }
    }

    async function enumerateCameras(){
      try{
        await ensurePermissions();
        const cams = await QrScanner.listCameras(true);
        devices = cams || [];
        cameraSelect.innerHTML = '';
        devices.forEach(c => { const opt = document.createElement('option'); opt.value = c.id; opt.textContent = c.label || c.id; cameraSelect.appendChild(opt); });
        const rear = pickRearCamera(devices);
        if(rear){ cameraSelect.value = rear.id; currentDeviceId = rear.id; }
        else if(devices[0]){ cameraSelect.value = devices[0].id; currentDeviceId = devices[0].id; }
        log('Devices enumerated', devices);
      }catch(e){ log('enumerateCameras error', e); }
    }

    async function destroyScanner(){
      if(frameScanInterval){ clearInterval(frameScanInterval); frameScanInterval = null; }
      if(qrScanner){ try{ await qrScanner.stop(); }catch(e){ log('stop error', e); } try{ qrScanner.destroy(); }catch(e){} qrScanner = null; }
    }

    async function stopStream(){
      if(currentStream){ try{ currentStream.getTracks().forEach(t => t.stop()); }catch(e){} currentStream = null; video.srcObject = null; }
      if(frameCanvas){ frameCanvas = null; }
    }

    // Fallback: cattura frame dal video e tenta scanImage
    function startFrameFallback(){
      if(!video || !video.videoWidth) return;
      if(frameScanInterval) clearInterval(frameScanInterval);
      frameCanvas = document.createElement('canvas');
      const w = Math.min(1024, video.videoWidth);
      const h = Math.min(768, video.videoHeight * (w / video.videoWidth));
      frameCanvas.width = w;
      frameCanvas.height = Math.round(h);
      const ctx = frameCanvas.getContext('2d');
      log('Frame fallback attivato', w, frameCanvas.height);
      frameScanInterval = setInterval(async () => {
        try{
          ctx.drawImage(video, 0, 0, frameCanvas.width, frameCanvas.height);
          // prova a decodificare direttamente dal canvas
          const text = await QrScanner.scanImage(frameCanvas, { returnDetailedScanResult: false }).catch(e => null);
          if(text){
            log('Fallback decoded', text);
            await onDecode(text);
          }
        }catch(e){ /* ignora */ }
      }, 600); // ogni 600ms
    }

    async function switchToDevice(deviceId){
      try{
        log('switchToDevice', deviceId);
        await destroyScanner();
        await stopStream();

        // richiedi caratteristiche più alte per migliorare decode (se il device lo supporta)
        const constraints = deviceId ? { video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } } } : { video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        await playVideoElement();

        // crea qrScanner **dopo** aver attaccato lo stream per garantire overlay
        qrScanner = new QrScanner(video, onDecode, { highlightScanRegion: true, maxScansPerSecond: 10 });
        await qrScanner.start();
        currentDeviceId = deviceId || null;
        log('Scanner avviato su', currentDeviceId);

        // avvia fallback frame scanner in background (solo se non decodifica)
        // startFrameFallback(); // non attiviamo subito per evitare duplicati; useremo un timeout per avviarlo se non c'è decode
        // se dopo 1.2s non abbiamo un risultato, avvia fallback
        setTimeout(() => {
          if(!lastResult && currentStream) startFrameFallback();
        }, 1200);
      }catch(err){ log('switchToDevice error', err); resultDisplay.textContent = 'Errore cambio camera: ' + (err && err.message ? err.message : err); }
    }

    function isValidUrl(str){ try{ new URL(str); return true; }catch(e){ return false; } }

    async function onDecode(result){
      if(!result) return;
      log('Decoded:', result);
      if(result === lastResult) return;
      lastResult = result;

      // mostra e scrive campo — NON riavviare automaticamente
      resultDisplay.textContent = result;
      resultInput.value = result;
      actions.classList.remove('hidden');

      try{ if(navigator.clipboard) await navigator.clipboard.writeText(result); log('Copied to clipboard'); }catch(e){ log('Copy failed', e); }
      if(navigator.vibrate) navigator.vibrate(120);
      try{ new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YRAAAAAA').play().catch(()=>{}); }catch(e){}

      // ferma tutto e pulisci fallback
      await destroyScanner();
      await stopStream();

      openBtn.disabled = !isValidUrl(result);
      openBtn.onclick = ()=>{ window.open(result, '_blank'); };
      copyBtn.onclick = async ()=>{ try{ await navigator.clipboard.writeText(result); resultDisplay.textContent = 'Copiato: '+result; }catch(e){ resultDisplay.textContent = 'Copia fallita: '+e.message; } };
      continueBtn.onclick = async ()=>{
        actions.classList.add('hidden');
        resultDisplay.textContent = 'Riavvio scansione...';
        lastResult = null;
        // dopo aver mostrato il risultato, riavvia lo stream sulla stessa device se possibile
        try{
          await switchToDevice(currentDeviceId || cameraSelect.value || null);
        }catch(e){ log('Errore riavvio dopo continue', e); }
      };
    }

    // event handlers
    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      await enumerateCameras();
      const preferred = currentDeviceId || cameraSelect.value || null;
      await switchToDevice(preferred);
      resultDisplay.textContent = 'In ascolto... inquadra un QR';
    });

    stopBtn.addEventListener('click', async () => { await destroyScanner(); await stopStream(); startBtn.disabled = false; resultDisplay.textContent = 'Camera fermata'; });

    cameraSelect.addEventListener('change', async () => { const id = cameraSelect.value; if(!id) return; await switchToDevice(id); });
    flipBtn.addEventListener('click', async () => { if(!devices || devices.length===0) return; const idx = devices.findIndex(d=>d.id===currentDeviceId); const next = devices[(idx+1)%devices.length] || devices[0]; cameraSelect.value = next.id; await switchToDevice(next.id); });

    torchCheckbox.addEventListener('change', async () => { const on = torchCheckbox.checked; if(!currentStream) return; const track = currentStream.getVideoTracks()[0]; if(!track) return; try{ await track.applyConstraints({ advanced: [{ torch: on }] }); }catch(e){ log('torch not supported', e); } });

    fileInput.addEventListener('change', async (ev) => { const f = ev.target.files && ev.target.files[0]; if(!f) return; resultDisplay.textContent = 'Scansione immagine...'; try{ const text = await QrScanner.scanImage(f, { returnDetailedScanResult: false }); onDecode(text); }catch(e){ resultDisplay.textContent = "Nessun QR nell'immagine"; } });

    (async ()=>{ await enumerateCameras(); })();
    window.addEventListener('beforeunload', async ()=>{ await destroyScanner(); await stopStream(); });
  </script>
</body>
</html>
